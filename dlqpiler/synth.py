#Filipe Chagas, 2023

import qiskit
from qiskit.providers.aer import AerSimulator
import pandas as pd
from qiskit.circuit.library.data_preparation.state_preparation import StatePreparation
from dlqpiler.ast import FullCode, RegisterExpressionDefinition, RegisterSetDefinition
from dlqpiler import utils
from typing import *

def reg_init_gate(values: Set[int], size: int) -> qiskit.circuit.Gate:
    """Returns the quantum initialization gate for a set of values

    :param values: Values ​​with which the register should be initialized
    :type values: Set[int]
    :param size: Register size
    :type size: int
    :return: StatePreparation gate
    :rtype: qiskit.circuit.Gate
    """
    if utils.is_none(values) or len(values)==0:
        qc = qiskit.QuantumCircuit(size)
        return qc.to_gate()
    else:
        return StatePreparation(utils.set_to_statevector(values, size))

def organize_qiskit_result(result_counts: Dict[str, int], registers_names: List[str], test_function: Callable[[dict], str] = None) -> pd.DataFrame:
    """Organize the results of the execution of a quantum circuit in a DataFrame.

    :param result_counts: Counts dict returned by Qiskit.
    :type result_counts: Dict[str, int]
    :param registers_names: List with the names of the registers.
    :type registers_names: List[str]
    :param registers_dtypes: List with the data types of the registers. 
    :type registers_dtypes: List[QQDTypes]
    :param test_function: A function that receives a dict with a value for each register and return a status about it.  Default to None.
    :type test_function: Callable[[dict], str], optional.
    :return: DataFrame containing the value of each register in each outcome and the frequencies of the outcomes.
    :rtype: pd.DataFrame
    """
    out_dict = {key:[] for key in registers_names+['$freq'] + (['$comment'] if isinstance(test_function, Callable) else [])}
    
    for full_bit_string in result_counts.keys():
        freq = result_counts[full_bit_string] #absolute frequency of the current bit-string
        reg_bit_string = full_bit_string.split(' ') #separate registers
        
        #Convert bit-strings to naturals, integers or booleans
        reg_data_list = []
        for i in range(len(reg_bit_string)):
            reg_data_list.append(utils.binary_to_natural([True if c=='1' else False for c in reg_bit_string[i]][::-1]))
            
        #Append results to the output dictionary
        for i in range(len(reg_bit_string)):
            out_dict[registers_names[i]].append(reg_data_list[-1-i])
        
        #Append tests to the output dict
        if isinstance(test_function, Callable):
            d = {registers_names[i]:reg_data_list[-1-i] for i in range(len(reg_bit_string))}
            tr = test_function(d)
            out_dict['$comment'].append(tr)

        out_dict['$freq'].append(freq)
        
    return pd.DataFrame(out_dict, ).sort_values('$freq', ascending=False).reset_index(drop=True)

class QuantumEvaluator():
    def __init__(self, code: FullCode) -> None:
        """
        :param code: Root ASTNode generated by the PLY analysis
        :type code: FullCode
        """
        self.quantum_circuit = qiskit.QuantumCircuit()
        code.check_definition_errors()
        self.code = code

        # --- Main registers ---
        self.main_registers_list = [(name, size, qiskit.QuantumRegister(size, f'q_{name}'), reg_init_gate(values, size)) for name, size, values in code.get_reg_names_sizes_and_sets()]
        self.main_classical_registers_list = [(name, size, qiskit.ClassicalRegister(size, name), reg_init_gate(values, size)) for name, size, values in code.get_reg_names_sizes_and_sets()]
        for i in range(len(self.main_registers_list)):
            qr = self.main_registers_list[i][2]
            cr = self.main_classical_registers_list[i][2]
            self.quantum_circuit.add_register(qr)
            self.quantum_circuit.add_register(cr)

        # --- Phase qubits ---
        phase_reg = qiskit.QuantumRegister(size=1, name='phase')
        self.quantum_circuit.add_register(phase_reg)
        self.phase_qubit = phase_reg[0]
            
        # --- Target qubit ---
        self.target_qubit = self.get_qiskit_register(self.code.terminator.target)[-1]

        # --- Ancilla qubits ---
        self.ancilla_qubits = dict() # id-to-object mapping
        self.clean_ancillas = []

    def get_qiskit_register(self, label: str) -> qiskit.QuantumRegister:
        """Returns the respective circuit register

        :param label: Register's label (name)
        :type label: str
        :return: Qiskit register objects
        :rtype: qiskit.QuantumRegister
        """
        for name, size, reg, ig in self.main_registers_list:
            if name == label:
                return reg
        return None
    
    def get_register_size(self, label: str) -> int:
        """Returns the respective register's size

        :param label: Register's label (name)
        :type label: str
        :return: 
        :rtype: int
        """
        for name, size, reg, ig in self.main_registers_list:
            if name == label:
                return size
        return None
    
    def alloc_ancilla(self) -> qiskit.circuit.AncillaQubit:
        """Allocate an ancilla qubit.

        :return: Qubit object
        :rtype: qiskit.circuit.AncillaQubit
        """
        if len(self.clean_ancillas) > 0: #If there are available clean ancillas
            #Get an existent clean ancilla
            qubit = self.clean_ancillas[0]
            del self.clean_ancillas[0]
        else:
            reg = qiskit.QuantumRegister(1)
            qubit = reg[0]
            self.quantum_circuit.add_register(reg)
            self.ancilla_qubits[id(qubit)] = qubit
        return qubit
        
    def free_ancilla(self, qubit: qiskit.circuit.AncillaQubit):
        """Release a clean ancilla qubit

        :param qubit: Ancilla to release
        :type qubit: qiskit.circuit.AncillaQubit
        """
        assert id(qubit) in self.ancilla_qubits.keys(), f'The ancilla qubit {id(qubit)} does not belong to the circuit'
        assert qubit not in self.clean_ancillas, f'The ancilla qubit {id(qubit)} is not in use'
        self.clean_ancillas.append(qubit)
    
    def initialize_registers(self):
        """Append the initialization gates to the quantum circuit
        """
        for regdef in self.code.regdefseq:
            if isinstance(regdef, RegisterSetDefinition):
                self.quantum_circuit.append(reg_init_gate(regdef.values, regdef.n), self.get_qiskit_register(regdef.name))
            
    def revert_registers_initialization(self):
        """Append the inverce initialization gates to the quantum circuit
        """
        for regdef in self.code.regdefseq[::-1]:
            if isinstance(regdef, RegisterSetDefinition):
                self.quantum_circuit.append(reg_init_gate(regdef.values, regdef.n).inverse(), self.get_qiskit_register(regdef.name))
                
    def build_evaluator(self):
        """Build a quantum circuit to evaluate the entire code
        """
        for regdef in self.code.regdefseq:
            if isinstance(regdef, RegisterExpressionDefinition):
                regdef.build(self)

    def revert_evaluator(self):
        """Build the inverse evaluation quantum circuit
        """
        for regdef in self.code.regdefseq[::-1]:
            if isinstance(regdef, RegisterExpressionDefinition):
                regdef.reverse(self)
            
    def append_measurements(self):
        """Append measurement gates
        """
        self.quantum_circuit.barrier()
        for i in range(len(self.main_registers_list)):
            qr = self.main_registers_list[i][2]
            cr = self.main_classical_registers_list[i][2]
            self.quantum_circuit.measure(qr, cr)

    def simulate(self, simulator: AerSimulator, shots=1024, test_function: Callable[[dict], str] = None) -> pd.DataFrame:
        """Execute the circuit using a qiskit simulator.

        :param simulator: Qiskit simulator.
        :type simulator: AerSimulator
        :param shots: Number of simulation shots, defaults to 1024
        :type shots: int, optional
        :param test_function: A function that receives a dict with a value for each register and return a status about it.  Default to None.
        :type test_function: Callable[[dict], str], optional
        :return: DataFrame generated by the organize_qiskit_result function.
        :rtype: pd.DataFrame
        """
        result_counts = qiskit.execute(self.quantum_circuit, simulator, shots=shots).result().get_counts()
        return organize_qiskit_result(
                result_counts,
                registers_names=[reg[0] for reg in self.main_registers_list], 
                test_function=test_function
            )
    
    def get_qubits(self) -> List[qiskit.circuit.Qubit]:
        """Returns a list with all the qubits in the circuit (except the phase qubit)

        :return: List of qubits
        :rtype: List[qiskit.circuit.Qubit]
        """
        qubits = []
        for name, size, reg, gate in self.main_registers_list:
            for qubit in reg:
                qubits.append(qubit) 

        for key in self.ancilla_qubits.keys():
            qubits.append(self.ancilla_qubits[key])

        return qubits
    
    def build_grover_search(self, iterations: int = 0):
        """Build the Grover's quantum search algorithm

        :param iterations: number of search iterations, defaults to 0
        :type iterations: int, optional
        """
        assert iterations >= 0

        self.quantum_circuit.h(self.phase_qubit)
        self.initialize_registers()
        qubits = self.get_qubits()

        for i in range(iterations):
            self.build_evaluator()
            self.quantum_circuit.barrier()
            self.quantum_circuit.cz(self.target_qubit, self.phase_qubit)
            self.quantum_circuit.barrier()
            self.revert_evaluator()
        
            #Diffusion operator
            self.quantum_circuit.barrier()
            self.revert_registers_initialization()
            self.quantum_circuit.x(qubits)
            self.quantum_circuit.z(self.phase_qubit)
            self.quantum_circuit.mcx(qubits, self.phase_qubit)
            self.quantum_circuit.z(self.phase_qubit)
            self.quantum_circuit.x(qubits)
            self.initialize_registers()
            self.quantum_circuit.barrier()
        

        self.build_evaluator()

    def build_all(self):
        """Build the entire quantum circuit
        """
        self.build_grover_search(self.code.terminator.it)
        self.append_measurements()